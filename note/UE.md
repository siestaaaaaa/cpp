> 工程就是权衡的艺术

# UObject

UObject 是 UE 对象系统的基类，具有完整的引用链，提供了通用的属性和接口、统一的 GC、反射、序列化

## GC

继承 UObject 且用 UPROPERTY 标记的成员变量，会参与 GC。GC 会自动触发，也可以手动触发

UE 采用的 GC 算法是标记-清理

1. 游戏线程获取 GC 锁，暂停其他线程对 UObject 的操作
2. 在一帧内，从根集开始遍历标记所有可达对象
   - ReferenceTokenStream 通过反射预生成对象引用链
   - 多线程加速遍历过程
   - 将一组对象视为簇，仅标记簇根对象
3. 回收不可达的对象，可以分帧进行
4. 游戏线程释放 GC 锁

### 内存泄漏

有 GC 也会内存泄漏吗？

会！忘记删除引用，GC 就一直无法回收对象，从而内存泄漏

## 反射

反射就是运行时获取类的信息

## 序列化

序列化就是将内存中的数据转换成另一种格式，用于持久化或网络传输，反序列化反之

UE 的序列化只会序列化必要的数据，如果成员变量的值等于默认值，则不会序列化（CDO）

### 指针的序列化

由于每次反序列化，对象的地址会改变，所以指针的序列化不能存储地址

UE 用一张表来记录被指针指向的对象，序列化指针的时候，存储的是表的索引

# AActor

继承 UObject，能被放置在关卡中，是网络同步的基本单位

# UActorComponent

继承 UObject，是所有组件的基类

组件可以给 AActor 附加某种能力，同时依赖 AActor 进行网络同步

# APawn

可被 Controller 操控的 AActor

# ACharacter

人形 APawn

# U++

## 模块

一个 UE 模块的组成：Public 目录、Private 目录、.Build.cs

## 命名规则

类的命名规则：

- 大驼峰，名词
- U：UObject
- A：AActor
- S：SWidget
- T：类模板
- I：抽象类
- E：枚举
- F：纯 C++ 类

变量命名规则：

- 大驼峰，名词
- bool 变量以 b 开头，小驼峰，问句

方法命名规则：

- 大驼峰，动词

## 创建对象

纯 C++ 类可以用 `new` 来创建对象，不过更建议使用 TSharedRef / TSharedPtr

# 联机开发

UE 的网络框架是 C/S 架构

## 网络协议

游戏最常用的网络协议是 UDP，通常会实现一套可靠的 UDP，然后混用可靠的 UDP 和不可靠的 UDP

重要的消息比如用户输入一般使用可靠的 UDP，不太重要的消息比如状态同步可以使用不可靠的 UDP

## NetMode

NM_Standalone：单机模式，没有网络连接，不区分客户端和服务器

NM_Client：纯客户端，游戏只跑客户端逻辑

NM_DedicatedServer：专用服务器，游戏只跑服务器逻辑

NM_ListenServer：监听服务器，允许其他客户端连接，游戏既充当客户端又充当服务器

总结：

1. 只要不是 DS，都要跑客户端逻辑
2. 只要不是 Client，都要跑服务器逻辑

## NetRole

AActor 是网络同步的基本单位，每个 AActor 都有自己的网络身份

- ROLE_Authority：服务器生成的 AActor 或客户端生成的 AActor
- ROLE_AutonomousProxy：服务器同步过来的 AActor 并且客户端具有主控权
- ROLE_SimulatedProxy：服务器同步过来的 AActor 并且客户端无主控权

## 网络同步

UE 的网络同步分为属性同步和 RPC

属性同步只用于服务器向客户端同步数据，给需要同步的属性标记 Replicated，并重写 GetLifetimeReplicatedProps 函数，当这些属性在服务器上发生变化，就会自动同步到客户端

-- RPC

## 移动同步

客户端本地处理移动输入，显示预测结果，同时将输入发给服务器

服务器收到后，重新模拟移动，将真实位置同步给客户端

客户端收到后，立即更新位置，同时平滑插值过渡

# AI

## 行为树

行为树由下列几种结点组成：

- 根结点
- 控制结点
  - Sequence：&&
  - Selector：||
- 装饰结点：修饰一个结点，改变其行为，比如条件判断等
- 叶子结点：执行具体操作

例子：
```
Root
  |
Selector
  |     \
  |      \
  |       \
Sequence  返回基地
  |  \  \
  |   \  \
  |    \  \
  |     \  \
  |      \  \
发现敌人 移动 攻击
```

# 渲染

## 三种线程

游戏线程并非直接向渲染线程派发任务，而是不断将任务添加到一个队列，渲染线程会异步地从队列里取出任务进行处理

渲染线程也并非直接向 GPU 发送指令，而是不断将渲染命令添加到命令列表，由 RHI 线程异步地从命令列表中取出命令，向 GPU 发送

从而使得 CPU 无需阻塞等待 GPU 执行指令
