> 整理自小林 coding

# 基础知识

## OSI模型

应用层：负责给应用程序提供网络服务

表示层：负责处理数据格式转换

会话层：负责管理设备间的会话

传输层：负责端到端的数据传输

网络层：负责跨网络的数据传输

数据链路层：负责相连结点之间的数据传输

物理层：负责数据在物理网络中的传输

OSI 模型比较复杂，实际使用的一般是 TCP/IP 模型

## TCP/IP模型

### 应用层

应用层负责给应用程序提供网络服务，应用层协议有 HTTP、DNS、FTP 等

应用层工作在用户态，其他层工作在内核态

### 传输层

传输层负责端到端的数据传输，传输层协议有 TCP、UDP 等

TCP 是可靠的、面向连接的、基于字节流的，UDP 是不可靠的、无连接的、基于数据报的

### 网络层

网络层负责跨网络的数据传输，网络层协议有 IP、ICMP 等

IP 地址：

- 由网络号和主机号组成，IPv4 地址占 32 位，IPv6 地址占 128 位
- IP 地址 & 子网掩码得到网络号，剩下的就是主机号
- 主机号全 0 代表这个局域网，主机号全 1 代表广播地址

### 网络接口层

网络接口层负责数据在物理网络中的传输，网络接口层协议有 ARP、RARP 等

网络接口层工作在网卡这个层次，使用 MAC 地址来标识网络上的设备

## 为什么要有网络协议

设备间的进程通信，需要通过网络，为了兼容不同的设备，就需要一套通用的网络协议

协议就是一种约定

## 报文的封装和分用

不同协议层传输的数据都可以叫报文

每一层协议的报文，都可以看成该层的报头 + 数据

发送端发送消息时，自顶向下每层协议会给报文添加该协议的报头

接收端接收消息时，自底向上每层协议会不断对报文进行解包分用

# HTTP

HTTP（超文本传输协议）是一个无连接、无状态的协议

## 请求报文

请求行：请求方法 URL 协议版本 \r\n

请求头：请求的附加信息，形式：`key: value\r\n`

空行：\r\n

请求体：请求的数据，通常用于 POST 请求等需要传输数据的情况

## 响应报文

状态行：协议版本 状态码 状态信息 \r\n

响应头：响应的附加信息，形式：`key: value\r\n`

空行：\r\n

响应体：响应的数据，通常是服务器返回的 HTML、JSON 等内容

## 常见状态码

1xx：信息性状态码

2xx：成功

- 200 OK：请求成功，服务器返回了所请求的资源
- 201 Created：请求成功，服务器创建了新的资源
- 204 No Content：请求成功，但没有内容返回
- 206 Partial Content：请求成功，但只返回了部分内容，一般用于分块下载或断点续传

3xx：重定向

- 301 Moved Permanently：请求的资源已被永久移动到新的 URL
- 302 Found：请求的资源临时从其他 URL 响应
- 304 Not Modified：资源未修改，客户端可以使用缓存的版本

4xx：客户端错误

- 400 Bad Request：服务器无法理解请求
- 401 Unauthorized：请求要求用户认证
- 403 Forbidden：服务器理解请求但拒绝执行
- 404 Not Found：请求的资源未找到

5xx：服务器错误

- 500 Internal Server Error：服务器内部错误
- 501 Not Implemented：服务器暂未实现
- 502 Bad Gateway：服务器作为网关或代理，访问上游服务器出错
- 503 Service Unavailable：当前服务不可用，通常是由于过载或维护
- 504 Gateway Timeout：服务器作为网关或代理，访问上游服务器超时

## 常见请求方法

GET：获取指定资源

POST：向指定资源提交数据

PUT：更新指定资源

DELETE：删除指定资源

HEAD：类似 GET，但只返回报头

## GET和POST的区别

GET 通过 URL 传参，只能是 ASCII 字符，且浏览器对 URL 有长度限制

POST 通过请求体传参，可以是任何格式的数据，且没有长度限制

GET 是幂等的，重复请求不会改变服务器状态，可以缓存

POST 不是幂等的，重复请求可能会改变服务器状态，不能缓存

## HTTP1.0

1. 短连接：每次请求都会创建连接，请求完成后关闭连接
2. 请求的队头阻塞：由于短连接的存在，客户端一次只能发送一个请求

## HTTP1.1

1. 默认使用长连接，减少连接创建销毁的开销
2. 因为是长连接，客户端一次可以发送多个请求，解决了请求的队头阻塞，但没有解决响应的队头阻塞

## HTTP2.0

1. 基于 HTTPS，解决了 HTTP 明文传输的问题
2. 头部压缩：对重复的头部字段进行压缩，减小头部大小
3. 二进制格式：采用二进制格式，提高传输效率
4. 并发传输：由于二进制分帧的特性，多个流可以在同一条连接上交错传输，接收方根据帧上的流标识符来组装消息
5. 服务器推送：服务器可以主动向客户端发送消息，不再是被动地响应
6. 解决了 HTTP 的队头阻塞，但没有解决 TCP 的队头阻塞（丢包需要等待 TCP 重传）

## HTTP3.0

1. 基于 UDP，彻底解决了 TCP 的队头阻塞
2. 在应用层实现了 QUIC 协议，改进了 TCP 的可靠传输
3. 整合 TLS 握手，提高创建连接的速度
4. 利用连接 ID 将不同网络的消息关联起来，实现连接迁移

## Cookie和Session

HTTP 本身是无状态的，因为每个 HTTP 请求都是独立的，服务器不会记录之前请求的状态，但是可以通过一些机制来保持状态，比如 Cookie 和 Session

Cookie 和 Session 都是服务器用来跟踪用户状态的机制

- 用户首次访问网站时，服务器会将 Cookie 信息发送到客户端，客户端之后的请求时会携带 Cookie 信息，用于服务器识别用户、跟踪用户行为、记录用户偏好等
- 用户首次访问网站时，服务器会为用户创建一个唯一的 Session ID，通过 Cookie 或 URL 重写的方式发送到客户端，客户端之后的请求会携带这个 Session ID，服务器根据 Session ID 找到对应的 Session 信息

Cookie 和 Session 的区别：

- Cookie 存储在客户端，Session 存储在服务器
- Cookie 大小限制通常为 4KB，而且浏览器对每个域名的 Cookie 数量是有限制的，Session 理论上没有大小限制，主要受限于服务器内存大小
- Cookie 相对不安全，因为存储在客户端，容易被篡改或窃取，Session 相对更安全，因为存储在服务器，但也要防范 Session 劫持
- Cookie 信息随每个请求发送到服务器，可能影响网络传输效率，Session 信息存储在服务器上，每次请求通过 Session ID 查询服务器上的 Session 信息，可能增加服务器负载

## HTTP和HTTPS

由于 HTTP 是明文传输，存在窃听、篡改、冒充的风险。所以 HTTPS 在 HTTP 和 TCP 之间加入了 SSL/TLS 协议

HTTP 在 TCP 三次握手建立连接之后就可以进行传输，HTTPS 还要进行 SSL/TLS 的四次握手：

1. 客户端发起请求，包含支持的加密套件、客户端生成的随机数
2. 服务器返回选择的加密套件、CA 证书和服务器生成的随机数
3. 客户端校验证书，生成预主密钥，用证书中的公钥加密后发给服务器
4. 服务器用私钥解密得到预主密钥

双方通过两个随机数和预主密钥生成会话密钥，后续通信使用会话密钥进行对称加密（SSL/TLS 握手是非对称加密，后续通信是对称加密）

对称加密和非对称加密：

- 对称加密只使用一个密钥，运算速度快，但是密钥必须保密，无法做到安全的密钥交换
- 非对称加密使用两个密钥，公钥可以任意分发而私钥保密，从而解决了密钥交换问题，但速度较慢

HTTPS 并不是绝对安全，需要防备中间人攻击（需要用户接受/安装第三方证书）（抓包工具也是这样实现的）

## HTTP和RPC

RPC 是一种通过网络调用远程服务的协议，可以实现高效的服务间通信

HTTP 主要用于 B/S 架构，RPC 主要用于 C/S 架构

RPC 出现的比 HTTP 早，且比主流的 HTTP/1.1 性能更好，所以很多公司内部还在使用 RPC

## HTTP和WebSocket

HTTP 是半双工的，WebSocket 是全双工的

WebSocket 适用于实时性要求较高的场景，比如在线聊天、实时游戏

# TCP

TCP 是一种可靠的、面向连接的、基于字节流的传输层协议

基于TCP的协议有：HTTP、HTTPS、SSH、FTP、SMTP

## TCP为什么可靠

### 序列号机制

序列号：初始序列号随机生成，之后每个字节的数据都会使序列号加 1，用来解决网络包乱序的问题

确认号：表示下一次期望收到的数据的序列号，确认号之前的数据被认为正常接收，用来解决丢包的问题

### 连接管理

#### 三次握手

1. 客户端发送 SYN（在吗）
    - 随机生成序列号，SYN 标志位设为 1
    - 发送报文，之后客户端处于 SYN-SENT 状态
2. 服务器收到 SYN，回复 ACK+SYN（在，在吗）
    - 随机生成序列号，设置确认号，SYN 和 ACK 标志位设为 1
    - 发送报文，之后服务器处于 SYN-RCVD 状态
    - 内核会将连接插入半连接队列
3. 客户端收到 ACK+SYN，返回 ACK（在）
    - 设置确认号，ACK 标志位设为 1
    - 发送报文，这次握手可以携带数据，之后客户端处于 ESTABLISHED 状态
4. 服务器收到 ACK，也进入 ESTABLISHED 状态
    - 内核会将连接从半连接队列取出，插入到全连接队列，供 accept() 取用

三次握手的作用：保证双方都有发送和接收的能力

为什么要三次握手：
- 防止重复建立历史连接
- 考虑网络拥堵的情况：旧 SYN 比新 SYN 先到达服务器，服务器对旧 SYN 回复 ACK+SYN，客户端收到 ACK 发现确认号对不上，就会返回 RST，服务器收到 RST 就会释放历史连接，由最新的 SYN 来建立连接。如果是两次握手，服务器就没有一个中间状态（SYN-RCVD）来阻止历史连接

四次握手可以吗：可以，但是 ACK+SYN 一般可以优化成一步

#### 四次挥手

1. 主动关闭方发送 FIN，进入 FIN_WAIT_1 状态
2. 被动关闭方收到 FIN，回复 ACK，进入 CLOSE_WAIT 状态，继续处理没发完的数据；主动关闭方收到 ACK，进入 FIN_WAIT_2 状态
3. 被动关闭方处理完数据，返回 FIN，进入 LAST_ACK 状态
4. 主动关闭方收到 FIN，回复 ACK，进入 TIME_WAIT 状态，等待 2MSL 时间，之后进入 CLOSE 状态；被动关闭方收到 ACK，进入 CLOSE 状态

为什么要等待 2MSL / 为什么要 TIME_WAIT：
- 确保最后的 ACK 到达（如果 ACK 丢包，主动关闭方收到重传的 FIN，定时器会重置回 2MSL）
- 使该连接上的所有报文都失效（MSL 是报文最大生存时间，一般 >= IP 层 TTL 减少到 0 的时间）

中间两次挥手可以合并吗：取决于被动关闭方是否还有数据要发送

### 超时重传

超过一定时间未收到 ACK，就会触发超时重传，重传报文的序列号不变

每次超时时间是上一次的两倍，达到最大重传次数后，会自动断开连接

### 流量控制

流量控制是通过在发送缓冲区维护一个滑动窗口来实现的

窗口内是可以直接发送的数据，窗口左侧是已确认的数据，右侧是未发送的数据

窗口大小取决于接收方的处理能力，通过 TCP 报头的窗口大小字段来控制

### 拥塞控制

网络拥堵时，丢包变多，TCP 的重传会加剧网络拥堵情况，导致更多的丢包，陷入恶性循环

所以 TCP 在发送端维护了一个拥塞窗口，根据网络拥堵情况控制发送速度（慢启动、拥塞避免、快重传、快恢复）

### 发送窗口到底多大

发送窗口大小 = min( 滑动窗口大小, 拥塞窗口大小 )

## TCP粘包怎么解决

TCP 是基于字节流的，没有边界，会有粘包的问题

最简单的方式是固定消息长度，但是这种方式不够灵活

1. 可以使用特殊字符作为边界，比如 HTTP 的 \r\n，但是要注意数据中对应的特殊字符要转义
2. 还可以自定义消息结构，在消息头部存一个字段来说明紧随其后的数据大小

## TCP的Keepalive和HTTP的Keep-Alive一样吗

不一样

HTTP 的 Keep-Alive 是长连接，可以复用一条 TCP 连接处理多个 HTTP 请求，减少连接创建销毁的开销

TCP 的 Keepalive 是 TCP 保活机制，当连接上长时间没有数据时，内核会发送探测报文检测对方是否在线，判断是否要关闭连接

## SYN攻击是什么

大量发送 SYN 包，可能占满服务器的半连接队列，后面收到的 SYN 就会丢包，导致无法建立连接

如何解决 SYN 攻击：

- 用一个队列保存处理不过来的数据包
- 增大半连接队列
- 绕过半连接队列建立连接

## TCP和UDP的区别

1. TCP 是可靠的；UDP 是不可靠的
2. TCP 是面向连接的，是一对一的两点服务；UDP 是无连接的，支持广播和多播
3. TCP 是基于字节流的，没有边界，会有粘包的问题；UDP 是基于数据报的，如果传输的数据很大，需要在应用层手动分包和拼装
4. TCP 适合需要可靠传输的场景（邮件、文件），UDP 适合实时性要求较高的场景（直播、游戏）

## UDP为什么不可靠

1. 不能保证数据顺序
2. 没有确认机制和重传机制
3. 如果接收缓冲区满了，再到达的报文会被丢弃

## UDP怎么实现可靠传输

将 TCP 的特性在应用层实现即可

- 引入序列号，保证数据顺序
- 引入确认机制和重传机制，确保收到数据

## TCP和UDP可以绑定同一端口吗

可以，TCP 和 UDP 在内核实现中是两个独立的模块，同一端口的 TCP 报文和 UDP 报文会给到对应的模块去处理

# 场景题

## 从输入网址到网页显示

1. URL 解析
   - URL = 协议 + 域名 + 端口（知名端口可以省略）+ 文件路径
   - 文件路径默认为 web 根目录下的 index.html
2. DNS 解析：获取域名对应的 IP 地址
   1. 浏览器缓存
   2. 操作系统缓存
   3. 本地 host 文件
   4. 本地域名服务器
   5. 递归查询/迭代查询：根域名服务器，顶级域名服务器，权威域名服务器
3. TCP 握手
4. TLS 握手
5. 浏览器发送请求
6. 网络传输
   - 网卡 - 交换机 - 路由器 - ... - 路由器 - 交换机 - 网卡
   - 源 IP 和 目标 IP 始终不变（前提是没有使用 NAT）
   - 源 MAC 和目标 MAC 会一直变化
7. 服务器处理请求，发送响应
8. 浏览器处理响应，渲染页面
9. TCP 挥手

## 服务器ping不通但HTTP请求成功

ping 基于 ICMP，HTTP 基于 TCP，有可能是服务器的防火墙禁止了 ICMP，没有禁止 TCP

## 127.0.0.1

127.0.0.1 是回环地址（约定），ping 回环地址和 ping 本机地址一样，都不会出网络

localhost 域名默认对应的 IP 地址就是 127.0.0.1

0.0.0.0 代表本机的所有 IP 地址，服务器 listen 时常用