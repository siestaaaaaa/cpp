> 整理自网络资料

# Linux环境

## 常用命令

`adduser xxx`：创建xxx用户

`usermod -aG sudo xxx`：给xxx用户分配 sudo 权限

`cat`：查看文件内容（大文件建议用 less）

`tail`：查看文件最后 n 行（经常用来查看日志）

`head`：查看文件前 n 行

`grep`：搜索文本

`find`：查找文件或目录

`chmod`：改变文件权限

`chown`：改变文件所有者

`env`：查看当前用户的环境变量

`ps aux`：查看所有进程

`top`：查看所有进程的信息

`free`：查看内存使用情况

`df`：查看硬盘使用情况

`time`：统计程序的执行时间

`ping`：测试本机到远程主机的连通性

```bash
netstat # 查看网络状态
# -n  show ip and port in number
# -p  add process info
# -t  only tcp
# -u  only udp
# -a  all except listen stat
# -l  only listen stat
```

## 常用工具

### SSH

SSH 是一种安全协议，用于加密网络通信

登录远程主机

```bash
ssh user@hostname
```

配置远程主机别名

```bash
vim ~/.ssh/config

Host xxx
	Hostname hostname
	User user

# 以后就可以用 xxx 代替 user@hostname
```

### GCC

Esc、iso

检测内存错误：-g -fsanitize=address

检测数据竞争：-g -fsanitize=thread

### GDB

`b 函数名/行号`：打断点

`b 函数名/行号 if (条件)`：打条件断点

`i b`：查看断点

`r`：重新运行程序

`s`：单步执行

`n`：单步执行，不会进入函数内部

`p 表达式`：打印值

`c`：执行到下一个断点

`d 断点号`：删除断点

`l 行号`：列出源代码

`bt`：查看堆栈信息

`help 命令`：查看某个 GDB 命令的使用方法

`q`：退出 GDB

### Make

Make 是一个基于 Makefile 的自动化构建工具

目标、依赖项、命令

增量更新：如果依赖项比目标新，则会重新构建目标

### CMake

CMake 是一个跨平台的构建工具，通过生成其他构建系统的文件（比如 Makefile）来构建项目

```bash
mkdir build
cd build
cmake ..
cmake --build .
```

### Git

Git 是一个版本控制工具，可以记录文件的修改，方便回滚版本

配置本地 Git 仓库

```bash
git config user.name xxx
git config user.email xxx

git init # 将当前目录配置成git仓库（信息记录在.git）
```

工作区、暂存区、版本库

```bash
git status # 查看仓库状态

git diff xxx    # 查看xxx在工作区相对于暂存区的修改
git restore xxx # 撤销xxx在工作区的修改

git add xxx              # 将xxx在工作区的修改添加到暂存区
git restore --staged xxx # 撤销xxx在暂存区的修改

git commit -m "xxx" # 将暂存区的修改打包成一个新的版本
                    # 单行提交信息

git commit -e       # 使用编辑器输入提交信息
git commit -s       # 提交信息附加署名

git commit --amend  # 将暂存区的修改追加到当前版本

git log    # 查看当前分支的历史
git reflog # 查看HEAD的移动历史

git reset --hard xxx # 将工作区、暂存区、当前分支的历史回退到xxx版本
git reset xxx        # 将暂存区、当前分支的历史回退到xxx版本
git reset --soft xxx # 将当前分支的历史回退到xxx版本
```

分支管理（分支是版本库层面的概念，每个分支的历史是独立的）

```bash
git checkout -b xxx # 创建并切换到xxx分支
git branch          # 查看所有分支
git checkout xxx    # 切换到xxx分支
git branch -d xxx   # 删除xxx分支

git merge xxx # 将xxx分支合并到当前分支
git rebase xxx # 将当前分支重放到xxx分支的顶部
```

rebase 和 merge 的区别：rebase 可以创造更线性的历史，会重写历史

# 操作系统

## 操作系统是什么

操作系统是一款管理软硬件资源的软件

## 系统调用

系统调用就是操作系统提供的 API，用于和内核交互

执行系统调用，操作系统会从用户态切换到内核态

## 用户态和内核态

用户态和内核态是操作系统的两种运行模式

- 用户态的权限低，无法访问硬件资源，用于运行用户程序
- 内核态的权限高，可以访问硬件资源，用于运行 OS 内核

通过区分用户态和内核态，可以更好的控制权限，提高操作的安全性

# 进程管理

## 进程概念

进程就是正在运行的程序

PCB 是进程存在的唯一标识，管理着进程的各种信息（pid、uid、状态、优先级）和资源（地址空间、页表、文件描述符表）

进程状态有：创建、就绪、运行、阻塞、挂起、结束

## 僵尸进程

僵尸进程已经结束了，但是 PCB 等资源没有释放

如何解决僵尸进程：

- 杀掉父进程，使僵尸进程变成孤儿进程，从而被 1 号进程接管
- 父进程调用 wait/waitpid 等待子进程结束
- 父进程忽略 SIGCHLD 信号，由内核对僵尸进程进行回收

## 进程线程协程

进程就是正在运行的程序，是资源分配的基本单位，每个进程都有自己的地址空间、页表、文件描述符表等资源，创建/销毁/切换开销较大，一般用于执行多个独立的任务

线程是进程内的执行单元，是系统调度的基本单位，只有自己的栈和寄存器，创建/销毁/切换开销较小，适合计算密集型的高并发任务

协程是一种用户态的线程，由应用程序调度，创建/销毁/切换的开销极小，可以简化异步编程（避免回调地狱），适合 IO 密集型的高并发任务

## 并行和并发

并行：一个时刻有多个事件发生

并发：一段时间有多个事件发生

## 调度算法

先来先服务：长作业阻塞短作业

短作业优先：长作业饿死

高响应比优先：需要频繁计算响应比

优先级调度：低优先级饿死

轮转调度：时间片太长会阻塞短作业，太短会增加上下文切换的开销

多级反馈队列：优先级调度 + 轮转调度 + 反馈（时间片用完则降低优先级，优先级越低时间片越长）

## 死锁

死锁是指多个进程/线程由于争夺资源而陷入互相等待的僵局，有四个必要条件：

- 互斥条件
- 请求与保持条件
- 不可剥夺条件
- 循环等待条件

怎么解决死锁：破坏死锁的任意一个必要条件即可，一般是通过固定锁的获取顺序来破坏循环等待条件

# 内存管理

## 虚拟内存

虚拟内存是操作系统的一种抽象机制，使每个进程都认为自己拥有连续、独立的地址空间（每个地址标识 1 字节）

1. 内核空间：只有内核态能访问，存放内核的代码和数据结构

2. 用户空间

- 栈：用于函数调用，存放函数参数、局部变量、返回地址等，向低地址增长，系统自动管理
- 内存映射区：mmap 作用的区域，包括文件映射（如动态库）和匿名映射（如线程栈）
- 堆：用于动态内存分配，向高地址增长，由程序显式分配释放，可能产生内存碎片
- 数据段：存放全局数据和静态数据
  - .bss 段：无初始值，只记录大小，程序加载时初始化成 0
  - .data 段：有初始值，会占用硬盘空间存储初始值数据
- 代码段：存放编译后的机器码，只读

代码段和数据段是程序编译链接时确定的，堆和栈在程序运行时动态变化

虚拟内存的作用：

- 保证每个进程的地址独立，将进程管理和内存管理解耦
- 多了一层虚拟地址，可以更好的控制访存安全（权限控制、ASLR）
- 可以利用硬盘的空间，增加可用内存的大小

## 写时复制

fork 创建子进程时，会把父进程的资源复制一份给子进程，但地址空间对应的物理内存不会复制

当子进程对内存进行写操作时，操作系统才进行物理内存的复制，并重新设置页表的映射关系

## 栈溢出

栈空间一般比较小，递归过深或较大的局部变量都可能导致栈溢出

可以调大栈空间大小，或者分配在堆上

## mmap

mmap 可以将文件映射到进程的用户空间，实现零拷贝访问

- 程序可以像操作内存一样操作文件，无需频繁的 read/write 系统调用，适合高频读写场景
- 内核通过缺页中断，按需将文件加载到物理内存，对大文件友好

## 动态内存分配

系统调用：

- brk：移动堆顶指针，释放时可能存在外碎片，适合小内存分配
- mmap：创建匿名映射，释放时直接归还操作系统，适合大内存分配

常见的分配器：

- glibc 的 ptmalloc：小于 128 KB 用 brk，大于 128 KB 用 mmap，主 arena 有一把全局锁，并发性能较差
- tcmalloc/jemalloc：优化多线程环境下的内存分配效率，tcmalloc 主要通过线程本地缓存，jemalloc 是将每个线程绑定到一个区域

## 分段机制

分段是把进程地址空间划分为不同的逻辑段，每个段通过段表映射到物理内存中

由于段的大小不固定，频繁分配释放可能会产生外碎片（物理内存）

## 分页机制

分页是把进程地址空间划分为固定大小的页（一般是 4KB），每个页通过页表映射到物理内存中

由于页的大小是固定的，所以不会有外碎片，但可能有内碎片

### 访存过程

当进程访问一个虚拟地址时，MMU 会将虚拟地址解析成页号和页内偏移量，根据页号找到对应的页表项，得到物理页的地址，再加上页内偏移量得到最后的物理地址

如果进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页中断，切换到内核态分配物理内存，更新页表，然后再访问

这个过程中可能还会涉及多级页表、TLB 等机制

### 多级页表

多级页表可以减小页表的占用空间，一级页表保存到二级页表的映射，二级页表按需创建，多级页表以此类推

缺点：虚拟地址到物理地址多了几层转换，增加了时间开销。可以用 TLB 缓存常用的页表项

### 页面置换

当物理内存不足时，操作系统会根据页面置换算法，选择一个页面换出到硬盘，腾出空间加载新页面

常见的页面置换算法：

- OPT：置换未来最久没有被访问的页面，实际无法实现
- FIFO：置换最先进入内存的页面
- LRU：置换最近最久没有被访问的页面
- LFU：置换访问次数最少的页面

# 进程间通信

## 管道

管道分为匿名管道和命名管道，匿名管道只能用于有亲缘关系的进程之间的通信，命名管道可以用于任意进程之间的通信

管道的本质是通过内核缓冲区传输数据，命名管道存在于文件系统的作用是作为一个标识符，让进程能访问到同一块缓冲区

管道是半双工的，双向通信需创建两个管道

管道传输的是字节流，如果写端关闭，读端 read 会返回 0

## 消息队列

消息队列是保存在内核中的消息链表，可以传输自定义类型的数据

消息队列可以实现生产者和消费者的解耦，消费者可以异步处理消息

## 共享内存

共享内存就是将同一块物理内存映射到多个进程的用户空间，是最快的进程间通信方式，没有用户态与内核态之间的数据拷贝

共享内存不提供同步机制，需要调用方自己处理

## 信号

信号是一种异步通知机制，用于通知进程发生了某种事件

信号的处理方式：默认、忽略、捕捉

捕捉：注册信号处理函数，内核在处理信号时会切换到用户态执行这个函数

不能忽略或捕捉的信号：SIGKILL、SIGSTOP

## 信号量

信号量是一种同步机制，相当于一个计数器，通过两个原子操作来控制

信号量非负时表示可用资源的数量，为负时表示阻塞线程的数量

## Socket

Socket 是内核提供的一套用于网络通信的 API

跨主机的进程间通信需要通过 Socket，Socket 也可以用于本地主机的进程间通信

Socket 常见的通信方式：基于 TCP 的通信、基于 UDP 的通信、本地进程间通信

> 客户端 Socket 的端口是随机的（OS 自动 bind）
>
> 服务端 Socket 的端口是固定的（需要手动 bind）

1. TCP 客户端：socket - connect - 数据传输

   TCP 服务器：socket - bind - listen - accept - 数据传输

2. UDP 客户端：socket - 数据传输

   UDP 服务器：socket - bind - 数据传输

## 线程间通信

同一进程内的线程共享进程的资源，线程间通信关注的是多线程同步的问题

互斥锁、条件变量、自旋锁、读写锁、信号量

# 文件系统

## 一切皆文件

Linux 下一切皆文件，文件、目录、管道、套接字等都是交给文件系统（VFS）管理的

inode：文件的唯一标识，记录文件的元信息（权限、大小、数据块指针等，不包含文件名）

## 硬链接

硬链接就是多个文件名指向同一个 inode

删除文件实际上只是减少硬链接数，当文件的硬链接数为 0 时，操作系统才真正删除这个文件

inode 是不跨文件系统的，所以硬链接是不跨文件系统的

## 软链接

软链接（符号链接）相当于一个新的文件，文件内容是另一个文件的文件名

软链接是可以跨文件系统的

删除软链接或其指向的文件，互相都不会受影响

## 文件描述符

文件描述符是一个非负整数，用于标识进程打开的文件

程序启动时会自动打开标准输入、标准输出和标准错误，对应的文件描述符是 0、1、2

文件描述符的分配规则：总是分配当前可用的最小整数

## 重定向

重定向就是通过修改文件描述符的指向，改变进程的输入/输出目标

重定向和管道的区别：

- 重定向是改变单个进程的输入/输出目标，不涉及数据传输（进程 <-> 文件）
- 管道是一种进程间通信机制，用于在两个进程间传输数据（进程A -> 管道 -> 进程B）

## IO模型

IO 过程分为准备数据和拷贝数据，同步 IO 和异步 IO 的区别在于拷贝数据这步

- 同步 IO 需要应用程序主动拷贝数据
- 异步 IO 由内核完成整个 IO 过程

同步 IO 模型：阻塞 IO、非阻塞 IO、信号驱动 IO、IO 多路复用

异步 IO 模型；异步 IO

## IO多路复用

IO 多路复用是一种高效的 IO 技术，允许一个线程同时监听多个 fd 的状态，从而提高 IO 效率

1. select
   - 将需要监听的 fd 放到一个 fd 集合，然后将这个集合拷贝到内核，内核通过轮询来检查 fd 的状态
   - 当数据就绪时，内核会标记对应的 fd，再将整个集合拷贝回用户态，返回就绪的 fd 数量
   - 用户通过遍历集合找到需要处理的 fd
   - 优点：跨平台
   - 缺点：fd 数量受限、拷贝开销大、轮询效率低
2. poll
   - 类似 select，区别在于 select 使用定长的位图来管理 fd 集合，poll 使用的是链表，fd 数量没有限制
   - 优点：跨平台、fd 数量不受限
   - 缺点：拷贝开销大、轮询效率低
3. epoll（Linux 特有）
   - 使用红黑树管理需要监听的 fd，只返回就绪链表中的 fd
   - 除了 LT，还支持 ET
     - LT：有数据就通知
     - ET：有新数据才通知
   - 优点：fd 数量不受限、拷贝开销小、红黑树效率高、支持 ET
   - 缺点：不跨平台

# 高性能网络

## Reacotr

主线程通过 IO 多路复用监听多个连接上的事件，事件触发后将任务分发给工作线程处理

- 单 Reacotr 单线程：监听、分发、处理都由同一个线程完成，无法利用多核，业务复杂时会阻塞 IO
- 单 Reacotr 多线程：主线程负责监听和分发，任务处理由工作线程完成
- 多 Reacotr 多线程：主 Reacotr 负责处理连接，子 Reacotr 负责监听和分发，任务处理由工作线程完成

## Proactor

应用程序提交 IO 请求后立即返回，由内核完成 IO 后通知应用程序，应用程序通过回调函数处理结果

Reacotr 需要应用程序自行读写数据（同步非阻塞），Proactor 由内核完成读写（异步），减少了上下文切换

## 线程池

线程池是一种预先创建并复用线程的技术，可以减少线程创建销毁的开销

核心参数

- 核心线程数：根据任务类型动态调整，一般为 CPU 核数 * 2
- 最大线程数：突发情况的扩容上限
- 任务队列：有界、无界、优先级
- 拒绝策略：队列满时的处理方式（丢弃任务、抛异常等）

## 开源方案

Nginx：多 Reactor 多进程

Redis：单 Reactor 单线程（避免锁竞争、瓶颈在内存）

Netty：多 Reactor 多线程

## 优化策略

零拷贝：使用 sendfile、mmap 等技术，减少数据拷贝，特别是大文件场景

无锁数据结构：比如任务队列使用无锁队列，减少锁竞争

连接复用：应用层保持长连接，减少连接创建销毁的开销

事件分发：将耗时任务与实时任务分离，使用独立事件循环，比如日志写入

负载均衡：多 Reactor 模型中，使用负载均衡算法分配连接，避免子 Reactor 负载不均
